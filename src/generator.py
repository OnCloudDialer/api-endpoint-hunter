"""Documentation generators for OpenAPI and Markdown."""

from __future__ import annotations

import json
import os
from datetime import datetime
from typing import Any
from urllib.parse import urlparse

import yaml
from jinja2 import Template
from rich.console import Console

from .models import (
    ContentType,
    CrawlConfig,
    EndpointGroup,
    HttpMethod,
    Parameter,
    ParameterLocation,
    ResponseBody,
    SchemaProperty,
    SchemaType,
)

console = Console()


class OpenAPIGenerator:
    """Generates OpenAPI 3.0 specification from analyzed endpoints."""
    
    def generate(self, endpoints: list[EndpointGroup], config: CrawlConfig) -> dict:
        """Generate OpenAPI 3.0 specification."""
        
        parsed = urlparse(config.start_url)
        
        spec = {
            "openapi": "3.0.3",
            "info": {
                "title": f"API Documentation - {parsed.netloc}",
                "description": f"Auto-generated API documentation for {config.start_url}\n\nGenerated by API Endpoint Hunter on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
                "version": "1.0.0",
            },
            "servers": [
                {
                    "url": f"{parsed.scheme}://{parsed.netloc}",
                    "description": "Target server",
                }
            ],
            "paths": {},
            "components": {
                "schemas": {},
                "securitySchemes": {},
            },
            "tags": [],
        }
        
        # Collect all tags
        all_tags = set()
        for endpoint in endpoints:
            all_tags.update(endpoint.tags)
        
        spec["tags"] = [{"name": tag} for tag in sorted(all_tags)]
        
        # Add security schemes based on config
        if config.auth_headers:
            if any("bearer" in v.lower() for v in config.auth_headers.values()):
                spec["components"]["securitySchemes"]["bearerAuth"] = {
                    "type": "http",
                    "scheme": "bearer",
                }
            if any("basic" in v.lower() for v in config.auth_headers.values()):
                spec["components"]["securitySchemes"]["basicAuth"] = {
                    "type": "http",
                    "scheme": "basic",
                }
        
        if config.cookies:
            spec["components"]["securitySchemes"]["cookieAuth"] = {
                "type": "apiKey",
                "in": "cookie",
                "name": list(config.cookies.keys())[0],
            }
        
        # Generate paths
        for endpoint in endpoints:
            path = endpoint.path_pattern
            method = endpoint.method.value.lower()
            
            if path not in spec["paths"]:
                spec["paths"][path] = {}
            
            operation = {
                "summary": endpoint.summary,
                "operationId": endpoint.operation_id,
                "tags": endpoint.tags,
            }
            
            if endpoint.description:
                operation["description"] = endpoint.description
            
            # Parameters
            if endpoint.parameters:
                operation["parameters"] = [
                    self._param_to_openapi(param)
                    for param in endpoint.parameters
                ]
            
            # Request body
            if endpoint.request_body:
                content_type = self._content_type_string(endpoint.request_body.content_type)
                operation["requestBody"] = {
                    "required": True,
                    "content": {
                        content_type: {
                            "schema": self._schema_to_openapi(endpoint.request_body.schema_properties),
                        }
                    }
                }
                if endpoint.request_body.example:
                    operation["requestBody"]["content"][content_type]["example"] = endpoint.request_body.example
            
            # Responses
            operation["responses"] = {}
            for status_code, response in endpoint.responses.items():
                resp_obj = {
                    "description": self._status_description(status_code),
                }
                
                if response.content_type != ContentType.UNKNOWN:
                    content_type = self._content_type_string(response.content_type)
                    resp_obj["content"] = {
                        content_type: {}
                    }
                    
                    if response.schema_properties:
                        # Check if response is an array
                        if response.example and isinstance(response.example, list):
                            resp_obj["content"][content_type]["schema"] = {
                                "type": "array",
                                "items": self._schema_to_openapi(response.schema_properties),
                            }
                        else:
                            resp_obj["content"][content_type]["schema"] = self._schema_to_openapi(response.schema_properties)
                    
                    if response.example:
                        resp_obj["content"][content_type]["example"] = response.example
                
                operation["responses"][str(status_code)] = resp_obj
            
            # Default response if none captured
            if not operation["responses"]:
                operation["responses"]["200"] = {"description": "Successful response"}
            
            spec["paths"][path][method] = operation
        
        return spec
    
    def _param_to_openapi(self, param: Parameter) -> dict:
        """Convert Parameter to OpenAPI parameter object."""
        obj = {
            "name": param.name,
            "in": param.location.value,
            "required": param.required,
            "schema": {
                "type": param.schema_type.value,
            },
        }
        
        if param.description:
            obj["description"] = param.description
        
        if param.example is not None:
            obj["example"] = param.example
        
        return obj
    
    def _schema_to_openapi(self, properties: dict[str, SchemaProperty]) -> dict:
        """Convert schema properties to OpenAPI schema object."""
        if not properties:
            return {"type": "object"}
        
        schema = {
            "type": "object",
            "properties": {},
        }
        
        required = []
        
        for name, prop in properties.items():
            prop_schema = {"type": prop.schema_type.value}
            
            if prop.description:
                prop_schema["description"] = prop.description
            
            if prop.example is not None:
                prop_schema["example"] = prop.example
            
            if prop.nullable:
                prop_schema["nullable"] = True
            
            # Handle nested objects
            if prop.schema_type == SchemaType.OBJECT and prop.properties:
                prop_schema = self._schema_to_openapi(prop.properties)
            
            # Handle arrays
            if prop.schema_type == SchemaType.ARRAY and prop.items:
                if prop.items.schema_type == SchemaType.OBJECT and prop.items.properties:
                    prop_schema["items"] = self._schema_to_openapi(prop.items.properties)
                else:
                    prop_schema["items"] = {"type": prop.items.schema_type.value}
            
            schema["properties"][name] = prop_schema
        
        if required:
            schema["required"] = required
        
        return schema
    
    def _content_type_string(self, content_type: ContentType) -> str:
        """Convert ContentType enum to string."""
        mapping = {
            ContentType.JSON: "application/json",
            ContentType.FORM: "application/x-www-form-urlencoded",
            ContentType.MULTIPART: "multipart/form-data",
            ContentType.XML: "application/xml",
            ContentType.TEXT: "text/plain",
            ContentType.HTML: "text/html",
        }
        return mapping.get(content_type, "application/octet-stream")
    
    def _status_description(self, status_code: int) -> str:
        """Get description for HTTP status code."""
        descriptions = {
            200: "Successful response",
            201: "Resource created",
            204: "No content",
            400: "Bad request",
            401: "Unauthorized",
            403: "Forbidden",
            404: "Not found",
            405: "Method not allowed",
            409: "Conflict",
            422: "Validation error",
            500: "Internal server error",
            502: "Bad gateway",
            503: "Service unavailable",
        }
        return descriptions.get(status_code, f"HTTP {status_code} response")


class MarkdownGenerator:
    """Generates Markdown documentation from analyzed endpoints."""
    
    TEMPLATE = '''# ðŸ“š API Documentation

> Auto-generated documentation for **{{ base_url }}**
>
> Generated on {{ generated_date }}

---

## Table of Contents

{% for tag in tags %}
- [{{ tag }}](#{{ tag | lower | replace(" ", "-") }})
{% endfor %}

---

## Overview

| Metric | Value |
|--------|-------|
| **Base URL** | `{{ base_url }}` |
| **Total Endpoints** | {{ total_endpoints }} |
| **HTTP Methods** | {{ methods | join(", ") }} |

---

{% for tag in tags %}
## {{ tag }}

{% for endpoint in endpoints_by_tag[tag] %}
### {{ endpoint.method.value }} `{{ endpoint.path_pattern }}`

{{ endpoint.summary }}

{% if endpoint.parameters %}
#### Parameters

| Name | Location | Type | Required | Description |
|------|----------|------|----------|-------------|
{% for param in endpoint.parameters %}
| `{{ param.name }}` | {{ param.location.value }} | {{ param.schema_type.value }} | {{ "Yes" if param.required else "No" }} | {{ param.description or "-" }} |
{% endfor %}

{% endif %}
{% if endpoint.request_body %}
#### Request Body

**Content-Type:** `{{ endpoint.request_body.content_type.value }}`

{% if endpoint.request_body.example %}
```json
{{ endpoint.request_body.example | tojson(indent=2) }}
```
{% endif %}

{% if endpoint.request_body.schema_properties %}
**Schema:**

| Property | Type | Description |
|----------|------|-------------|
{% for name, prop in endpoint.request_body.schema_properties.items() %}
| `{{ name }}` | {{ prop.schema_type.value }} | {{ prop.description or "-" }} |
{% endfor %}

{% endif %}
{% endif %}
#### Responses

{% for status_code, response in endpoint.responses.items() %}
##### {{ status_code }} - {{ status_description(status_code) }}

{% if response.example %}
```json
{{ response.example | tojson(indent=2) }}
```
{% endif %}

{% endfor %}
---

{% endfor %}
{% endfor %}

## Authentication

{% if auth_info %}
{{ auth_info }}
{% else %}
Authentication details were not explicitly configured. Check the captured requests for authentication patterns.
{% endif %}

---

*Documentation generated by [API Endpoint Hunter](https://github.com/your-repo/api-endpoint-hunter)*
'''
    
    def generate(self, endpoints: list[EndpointGroup], config: CrawlConfig) -> str:
        """Generate Markdown documentation."""
        
        parsed = urlparse(config.start_url)
        base_url = f"{parsed.scheme}://{parsed.netloc}"
        
        # Collect tags and group endpoints
        tags = set()
        endpoints_by_tag: dict[str, list[EndpointGroup]] = {}
        
        for endpoint in endpoints:
            for tag in endpoint.tags:
                tags.add(tag)
                if tag not in endpoints_by_tag:
                    endpoints_by_tag[tag] = []
                endpoints_by_tag[tag].append(endpoint)
        
        tags = sorted(tags)
        
        # Collect methods
        methods = sorted(set(ep.method.value for ep in endpoints))
        
        # Auth info
        auth_info = ""
        if config.auth_headers:
            auth_info += "**Headers configured:**\n"
            for key in config.auth_headers.keys():
                auth_info += f"- `{key}`\n"
        if config.cookies:
            auth_info += "\n**Cookies configured:**\n"
            for key in config.cookies.keys():
                auth_info += f"- `{key}`\n"
        if config.login_url:
            auth_info += f"\n**Form login URL:** `{config.login_url}`\n"
        
        # Render template
        template = Template(self.TEMPLATE)
        
        def status_description(code: int) -> str:
            descriptions = {
                200: "OK",
                201: "Created",
                204: "No Content",
                400: "Bad Request",
                401: "Unauthorized",
                403: "Forbidden",
                404: "Not Found",
                422: "Validation Error",
                500: "Server Error",
            }
            return descriptions.get(code, f"Status {code}")
        
        markdown = template.render(
            base_url=base_url,
            generated_date=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            tags=tags,
            endpoints_by_tag=endpoints_by_tag,
            total_endpoints=len(endpoints),
            methods=methods,
            auth_info=auth_info,
            status_description=status_description,
        )
        
        return markdown


class DocumentationWriter:
    """Writes documentation to files."""
    
    def __init__(self, output_dir: str):
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)
    
    def write_openapi(self, spec: dict, format: str = "yaml"):
        """Write OpenAPI spec to file."""
        if format == "yaml":
            filepath = os.path.join(self.output_dir, "openapi.yaml")
            with open(filepath, "w") as f:
                yaml.dump(spec, f, default_flow_style=False, sort_keys=False, allow_unicode=True)
        else:
            filepath = os.path.join(self.output_dir, "openapi.json")
            with open(filepath, "w") as f:
                json.dump(spec, f, indent=2)
        
        console.print(f"[green]âœ“[/] OpenAPI spec written to: [bold]{filepath}[/]")
        return filepath
    
    def write_markdown(self, markdown: str):
        """Write Markdown documentation to file."""
        filepath = os.path.join(self.output_dir, "api-docs.md")
        with open(filepath, "w") as f:
            f.write(markdown)
        
        console.print(f"[green]âœ“[/] Markdown docs written to: [bold]{filepath}[/]")
        return filepath
    
    def write_raw_endpoints(self, endpoints: list[EndpointGroup]):
        """Write raw endpoint data to JSON file."""
        filepath = os.path.join(self.output_dir, "endpoints.json")
        
        # Convert to serializable format
        data = []
        for endpoint in endpoints:
            data.append({
                "method": endpoint.method.value,
                "path": endpoint.path_pattern,
                "base_url": endpoint.base_url,
                "summary": endpoint.summary,
                "tags": endpoint.tags,
                "parameters": [
                    {
                        "name": p.name,
                        "location": p.location.value,
                        "type": p.schema_type.value,
                        "required": p.required,
                        "example": p.example,
                    }
                    for p in endpoint.parameters
                ],
                "request_body": {
                    "content_type": endpoint.request_body.content_type.value,
                    "example": endpoint.request_body.example,
                } if endpoint.request_body else None,
                "responses": {
                    str(code): {
                        "content_type": resp.content_type.value,
                        "example": resp.example,
                    }
                    for code, resp in endpoint.responses.items()
                },
                "captured_count": len(endpoint.captured),
            })
        
        with open(filepath, "w") as f:
            json.dump(data, f, indent=2, default=str)
        
        console.print(f"[green]âœ“[/] Raw endpoint data written to: [bold]{filepath}[/]")
        return filepath
